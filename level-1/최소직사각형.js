/*
크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.

모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.
*/

//my sol
function solution(sizes) {
  const arr = [0, 0];
  const ordered = sizes.map((a) => a.sort((a, b) => a - b));
  ordered.map((a) => {
    const x = a[0];
    const y = a[1];
    if (x > arr[0]) arr[0] = x;
    if (y > arr[1]) arr[1] = y;
  });
  return arr[0] * arr[1];
}
/*
테스트 1 〉	통과 (0.17ms, 30.1MB)
테스트 2 〉	통과 (0.08ms, 30.3MB)
테스트 3 〉	통과 (0.14ms, 30.2MB)
테스트 4 〉	통과 (0.13ms, 30.1MB)
테스트 5 〉	통과 (0.13ms, 30.1MB)
테스트 6 〉	통과 (0.12ms, 29.9MB)
테스트 7 〉	통과 (0.12ms, 30MB)
테스트 8 〉	통과 (0.09ms, 30.2MB)
테스트 9 〉	통과 (0.09ms, 29.9MB)
테스트 10 〉	통과 (0.15ms, 30.1MB)
테스트 11 〉	통과 (0.16ms, 30.3MB)
테스트 12 〉	통과 (0.26ms, 30.2MB)
테스트 13 〉	통과 (0.46ms, 30.3MB)
테스트 14 〉	통과 (1.64ms, 31.4MB)
테스트 15 〉	통과 (2.24ms, 31.7MB)
테스트 16 〉	통과 (3.89ms, 32.6MB)
테스트 17 〉	통과 (4.85ms, 35.5MB)
테스트 18 〉	통과 (5.37ms, 35.3MB)
테스트 19 〉	통과 (6.63ms, 36.8MB)
테스트 20 〉	통과 (7.76ms, 38.1MB)
*/
